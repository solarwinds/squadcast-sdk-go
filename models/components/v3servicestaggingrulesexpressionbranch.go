// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/SquadcastHub/squadcast-sdk-go/internal/utils"
)

type V3ServicesTaggingRulesExpressionBranchOp string

const (
	V3ServicesTaggingRulesExpressionBranchOpIs          V3ServicesTaggingRulesExpressionBranchOp = "is"
	V3ServicesTaggingRulesExpressionBranchOpIsNot       V3ServicesTaggingRulesExpressionBranchOp = "is_not"
	V3ServicesTaggingRulesExpressionBranchOpMatches     V3ServicesTaggingRulesExpressionBranchOp = "matches"
	V3ServicesTaggingRulesExpressionBranchOpNotContains V3ServicesTaggingRulesExpressionBranchOp = "not_contains"
	V3ServicesTaggingRulesExpressionBranchOpGt          V3ServicesTaggingRulesExpressionBranchOp = "gt"
	V3ServicesTaggingRulesExpressionBranchOpLt          V3ServicesTaggingRulesExpressionBranchOp = "lt"
	V3ServicesTaggingRulesExpressionBranchOpGtEq        V3ServicesTaggingRulesExpressionBranchOp = "gt_eq"
	V3ServicesTaggingRulesExpressionBranchOpLtEq        V3ServicesTaggingRulesExpressionBranchOp = "lt_eq"
	V3ServicesTaggingRulesExpressionBranchOpCall        V3ServicesTaggingRulesExpressionBranchOp = "call"
	V3ServicesTaggingRulesExpressionBranchOpFieldIs     V3ServicesTaggingRulesExpressionBranchOp = "field_is"
	V3ServicesTaggingRulesExpressionBranchOpFieldIsNot  V3ServicesTaggingRulesExpressionBranchOp = "field_is_not"
	V3ServicesTaggingRulesExpressionBranchOpFieldGt     V3ServicesTaggingRulesExpressionBranchOp = "field_gt"
	V3ServicesTaggingRulesExpressionBranchOpFieldLt     V3ServicesTaggingRulesExpressionBranchOp = "field_lt"
	V3ServicesTaggingRulesExpressionBranchOpFieldGtEq   V3ServicesTaggingRulesExpressionBranchOp = "field_gt_eq"
	V3ServicesTaggingRulesExpressionBranchOpFieldLtEq   V3ServicesTaggingRulesExpressionBranchOp = "field_lt_eq"
)

func (e V3ServicesTaggingRulesExpressionBranchOp) ToPointer() *V3ServicesTaggingRulesExpressionBranchOp {
	return &e
}
func (e *V3ServicesTaggingRulesExpressionBranchOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "is":
		fallthrough
	case "is_not":
		fallthrough
	case "matches":
		fallthrough
	case "not_contains":
		fallthrough
	case "gt":
		fallthrough
	case "lt":
		fallthrough
	case "gt_eq":
		fallthrough
	case "lt_eq":
		fallthrough
	case "call":
		fallthrough
	case "field_is":
		fallthrough
	case "field_is_not":
		fallthrough
	case "field_gt":
		fallthrough
	case "field_lt":
		fallthrough
	case "field_gt_eq":
		fallthrough
	case "field_lt_eq":
		*e = V3ServicesTaggingRulesExpressionBranchOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for V3ServicesTaggingRulesExpressionBranchOp: %v", v)
	}
}

type V3ServicesTaggingRulesExpressionBranchRHSType string

const (
	V3ServicesTaggingRulesExpressionBranchRHSTypeStr     V3ServicesTaggingRulesExpressionBranchRHSType = "str"
	V3ServicesTaggingRulesExpressionBranchRHSTypeBoolean V3ServicesTaggingRulesExpressionBranchRHSType = "boolean"
	V3ServicesTaggingRulesExpressionBranchRHSTypeInt32   V3ServicesTaggingRulesExpressionBranchRHSType = "int32"
	V3ServicesTaggingRulesExpressionBranchRHSTypeFloat32 V3ServicesTaggingRulesExpressionBranchRHSType = "float32"
)

type V3ServicesTaggingRulesExpressionBranchRHS struct {
	Str     *string  `queryParam:"inline,name=rhs"`
	Boolean *bool    `queryParam:"inline,name=rhs"`
	Int32   *int     `queryParam:"inline,name=rhs"`
	Float32 *float32 `queryParam:"inline,name=rhs"`

	Type V3ServicesTaggingRulesExpressionBranchRHSType
}

func CreateV3ServicesTaggingRulesExpressionBranchRHSStr(str string) V3ServicesTaggingRulesExpressionBranchRHS {
	typ := V3ServicesTaggingRulesExpressionBranchRHSTypeStr

	return V3ServicesTaggingRulesExpressionBranchRHS{
		Str:  &str,
		Type: typ,
	}
}

func CreateV3ServicesTaggingRulesExpressionBranchRHSBoolean(boolean bool) V3ServicesTaggingRulesExpressionBranchRHS {
	typ := V3ServicesTaggingRulesExpressionBranchRHSTypeBoolean

	return V3ServicesTaggingRulesExpressionBranchRHS{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateV3ServicesTaggingRulesExpressionBranchRHSInt32(int32T int) V3ServicesTaggingRulesExpressionBranchRHS {
	typ := V3ServicesTaggingRulesExpressionBranchRHSTypeInt32

	return V3ServicesTaggingRulesExpressionBranchRHS{
		Int32: &int32T,
		Type:  typ,
	}
}

func CreateV3ServicesTaggingRulesExpressionBranchRHSFloat32(float32T float32) V3ServicesTaggingRulesExpressionBranchRHS {
	typ := V3ServicesTaggingRulesExpressionBranchRHSTypeFloat32

	return V3ServicesTaggingRulesExpressionBranchRHS{
		Float32: &float32T,
		Type:    typ,
	}
}

func (u *V3ServicesTaggingRulesExpressionBranchRHS) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = V3ServicesTaggingRulesExpressionBranchRHSTypeStr
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = V3ServicesTaggingRulesExpressionBranchRHSTypeBoolean
		return nil
	}

	var int32Var int = 0
	if err := utils.UnmarshalJSON(data, &int32Var, "", true, nil); err == nil {
		u.Int32 = &int32Var
		u.Type = V3ServicesTaggingRulesExpressionBranchRHSTypeInt32
		return nil
	}

	var float32Var float32 = float32(0)
	if err := utils.UnmarshalJSON(data, &float32Var, "", true, nil); err == nil {
		u.Float32 = &float32Var
		u.Type = V3ServicesTaggingRulesExpressionBranchRHSTypeFloat32
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for V3ServicesTaggingRulesExpressionBranchRHS", string(data))
}

func (u V3ServicesTaggingRulesExpressionBranchRHS) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Int32 != nil {
		return utils.MarshalJSON(u.Int32, "", true)
	}

	if u.Float32 != nil {
		return utils.MarshalJSON(u.Float32, "", true)
	}

	return nil, errors.New("could not marshal union type V3ServicesTaggingRulesExpressionBranchRHS: all fields are null")
}

type V3ServicesTaggingRulesExpressionBranch struct {
	LHS string                                    `json:"lhs"`
	Op  *V3ServicesTaggingRulesExpressionBranchOp `json:"op,omitempty"`
	RHS V3ServicesTaggingRulesExpressionBranchRHS `json:"rhs"`
}

func (v *V3ServicesTaggingRulesExpressionBranch) GetLHS() string {
	if v == nil {
		return ""
	}
	return v.LHS
}

func (v *V3ServicesTaggingRulesExpressionBranch) GetOp() *V3ServicesTaggingRulesExpressionBranchOp {
	if v == nil {
		return nil
	}
	return v.Op
}

func (v *V3ServicesTaggingRulesExpressionBranch) GetRHS() V3ServicesTaggingRulesExpressionBranchRHS {
	if v == nil {
		return V3ServicesTaggingRulesExpressionBranchRHS{}
	}
	return v.RHS
}
